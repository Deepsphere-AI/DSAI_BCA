
/*******************************************************************************************

File Name       :   CSLAB_SAMPLED_RDD_V1
Purpose 	:   Code for Sampled RDD in Scala
Author		:   Durga Prasad
Reviewer 	:   Jothi Periasamy
Date and Time	:   01/21/2015 17:54 hrs
Version		:   1.0	
Change History 	: 

____________________________________________________________________________________________

	Who				   When 			  Why
____________________________________________________________________________________________


	DP				01/21/2015		    Initital Release 

____________________________________________________________________________________________


/*******************************************************************************************

  package org.apache.spark.examples.mllib

  import scopt.OptionParser

  import org.apache.spark.{SparkConf, SparkContext}

  import org.apache.spark.SparkContext._

  import org.apache.spark.mllib.util.MLUtils

  object SampledRDDs {

  case class Params(input: String = "data/mllib/sample_binary_classification_data.txt")
    
  extends AbstractParams[Params]

  def main(args: Array[String]) {
    
  val defaultParams = Params()

  val parser = new OptionParser[Params]("SampledRDDs") {
  
  head("SampledRDDs: an example app for randomly generated and sampled RDDs.")
  
  opt[String]("input")
  
  .text(s"Input path to labeled examples in LIBSVM format, default: ${defaultParams.input}")
  
  .action((x, c) => c.copy(input = x))
  
   parser.parse(args, defaultParams).map { params =>
      
   run(params)
    
  } getOrElse {
      
  sys.exit(1)
    
  }
  
  }

  def run(params: Params) {
    
  val conf = new SparkConf().setAppName(s"SampledRDDs with $params")
    
  val sc = new SparkContext(conf)

  val fraction = 0.1 // fraction of data to sample

  val examples = MLUtils.loadLibSVMFile(sc, params.input)
  
  val numExamples = examples.count()
  
  if (numExamples == 0) {
  
  throw new RuntimeException("Error: Data file had no samples to load.")
    
  }
  
  println(s"Loaded data with $numExamples examples from file: ${params.input}")

  val expectedSampleSize = (numExamples * fraction).toInt
    
  println(s"Sampling RDD using fraction $fraction.  Expected sample size = $expectedSampleSize.")
    
  val sampledRDD = examples.sample(withReplacement = true, fraction = fraction)
    
  println(s"  RDD.sample(): sample has ${sampledRDD.count()} examples")
    
  val sampledArray = examples.takeSample(withReplacement = true, num = expectedSampleSize)
    
  println(s"  RDD.takeSample(): sample has ${sampledArray.size} examples")
    
  println()

  val keyedRDD = examples.map { lp => (lp.label.toInt, lp.features) }
    
  println(s"  Keyed data using label (Int) as key ==> Orig")
    
  val keyCounts = keyedRDD.countByKey()

  val fractions = keyCounts.keys.map((_, fraction)).toMap
    
  val sampledByKeyRDD = keyedRDD.sampleByKey(withReplacement = true, fractions = fractions)
    
  val keyCountsB = sampledByKeyRDD.countByKey()
    
  val sizeB = keyCountsB.values.sum
    
  println(s"  Sampled $sizeB examples using approximate stratified sampling (by label)." +
      " ==> Approx Sample")

  val sampledByKeyRDDExact =
      
  keyedRDD.sampleByKeyExact(withReplacement = true, fractions = fractions)
    
  val keyCountsBExact = sampledByKeyRDDExact.countByKey()
    
  val sizeBExact = keyCountsBExact.values.sum
    
  println(s"  Sampled $sizeBExact examples using exact stratified sampling (by label)." +
      " ==> Exact Sample")

  println(s"   \tFractions of examples with key")
    
  println(s"Key\tOrig\tApprox Sample\tExact Sample")
    
  keyCounts.keys.toSeq.sorted.foreach { key =>
      
  val origFrac = keyCounts(key) / numExamples.toDouble
  
  val approxFrac = if (sizeB != 0) {
 
  keyCountsB.getOrElse(key, 0L) / sizeB.toDouble
  
  } else {
        
  0
      
  }
   
  val exactFrac = if (sizeBExact != 0) {
  
   keyCountsBExact.getOrElse(key, 0L) / sizeBExact.toDouble
  
  } else {
        
  0
      
  }
  
  println(s"$key\t$origFrac\t$approxFrac\t$exactFrac")
    
  }

  sc.stop()
  
  }

  }
  
/*******************************************************************************************
  Disclaimer.

      We are providing this code block strictly for learning and researching, this is not a 
production ready code. We have no liability on this particular code under any circumstances; 
users should use this code on their own risk. All software, hardware and othr products that 
are referenced in these materials belong to the respective vendor who developed or who owns 
this product.

/*******************************************************************************************
  
